本指南适用于新的Racket程序员或部分新的Racket程序员。本指南假定你是有编程经验的。如果您是新学习编程，那么请阅读《如何设计程序》（How to Design Programs）这部分。如果你想特别快地了解Racket语言，从这里开始：《快速：用图片介绍Racket》《 Quick: An Introduction to Racket with Pictures》这部分。

第2章简要介绍Racket语言。从第3章开始，本指南深入讨论了大部分的Racket语言工具箱，但把更清晰的细节内容留给Racket语言参考手册和其他参考手册介绍。

1 Racket语言欢迎你(OK)
  1.1 与Racket语言交互(OK)
  1.2 定义和交互（OK）
  1.3 创建可执行文件（OK）
  1.4 给有LISP/Scheme经验的读者的一个说明（OK）

2 Racket语言概要(OK)
  2.1 简单值(OK)
  2.2 简单的定义与表达式(OK)
    2.2.1 定义(OK)
    2.2.2 代码缩进（OK）
    2.2.3 标识符（OK）
    2.2.4 函数调用(应用程序)（OK）
    2.2.5 条件表达式if、and、or和cond（OK）
    2.2.6 函数重复调用（OK）
    2.2.7 匿名函数与lambda（OK）
    2.2.8 用define、let和let*实现局部绑定（OK）
  2.3 列表、迭代和递归（OK）
    2.3.1 预定义列表循环（OK）
    2.3.2 从头开始列表迭代（OK）
    2.3.3 尾递归（OK）
    2.3.4 递归和迭代（OK）
  2.4 配对（pair）、列表（list）和Racket的语法（OK）
    2.4.1 用quote引用pair和symbol（OK）
    2.4.2 使用’缩写quote（OK）
    2.4.3 列表和Racket的语法（OK）

3 内置的数据类型（OK）
  3.1 布尔值（Boolean）（OK）
  3.2 数值（Number）（OK）
  3.3 字符（Character）（OK）
  3.4 字符串（Unicode Strings）（OK）
  3.5 字节（Byte）和字节字符串（Byte String）（OK）
  3.6 符号（Symbol）（OK）
  3.7 关键字（Keyword）（OK）
  3.8 配对（Pair）和列表（List）（OK）
  3.9 向量（Vector）（OK）
  3.10 哈希表（Hash Table）（OK）
  3.11 格子（Box）（OK）
  3.12 空值（Void）和未定义值（Undefined）（OK）

4 表达式和定义（OK）
  4.1 标记法（OK）
  4.2 标识符和绑定（OK）
  4.3 函数调用（过程程序）（OK）
    4.3.1 求值顺序和元数（OK）
    4.3.2 关键字参数（OK）
    4.3.3 apply函数（OK）
  4.4 lambda函数（程序）（OK）
    4.4.1 申明剩余（rest）参数（OK）
    4.4.2 声明可选（optional）参数（OK）
    4.4.3 声明关键字（keyword）参数（OK）
    4.4.4 多解函数：case-lambda（OK）
  4.5 定义：define（OK）
    4.5.1 函数简写（OK）
    4.5.2 咖喱函数简写（OK）
    4.5.3 多值和define-values（OK）
    4.5.4 内部定义（OK）
  4.6 局部绑定（OK）
    4.6.1 平行绑定：let（OK）
    4.6.2 顺序绑定：let*（OK）
    4.6.3 递归绑定：letrec（OK）
    4.6.4 命名let（OK）
    4.6.5 多值绑定：let-values，let*-values，letrec-values（OK）
  4.7 条件分支（OK）
    4.7.1 简单分支：if（OK）
    4.7.2 组合测试：and和or（OK）
    4.7.3 约束测试：cond（OK）
  4.8 排序（OK）
    4.8.1 前置影响：begin（OK）
    4.8.2 后置影响：begin0（OK）
    4.8.3 if影响：when和unless（OK）
  4.9 赋值：set!（OK）
    4.9.1 使用赋值的指导原则（OK）
    4.9.2 多值赋值：set!-values（OK）
  4.10 引用：quote和'（OK）
  4.11 准引用：quasiquote和`（OK）
  4.12 简单分派：case（OK）
  4.13 动态绑定：parameterize（OK）

5 自定义的数据类型（OK）
  5.1 简单的结构类型：struct（OK）
  5.2 复制和更新（OK）
  5.3 结构子类（OK）
  5.4 不透明结构与透明结构的对比（OK）
  5.5 结构的比较（OK）
  5.6 结构类型的生成性（OK）
  5.7 预制结构（OK）
  5.8 更多的结构选项（OK）

6 模块（OK）
  6.1 模块基础知识（OK）
    6.1.1 组织模块（OK）
    6.1.2 库集合（OK）
    6.1.3 包和集合（OK）
    6.1.4 添加集合（OK）
  6.2 模块的语法（OK）
    6.2.1 module表（OK）
    6.2.2 #lang简写（OK）
    6.2.3 子模块（OK）
    6.2.4 main和test子模块（OK）
  6.3 模块的路径（OK）
  6.4 导入：require（OK）
  6.5 输出：provide（OK）
  6.6 赋值和重定义（OK）

7 合约（OK）
  7.1 合约和边界（OK）
    7.1.1合约的违反（OK）
    7.1.2 合约与模块的测试（OK）
    7.1.3 嵌套合约的测试（OK）
  7.2 函数的简单合约（OK）
    7.2.1 ->类型（OK）
    7.2.2 define/contract和->的使用（OK）
    7.2.3 and和any/c（OK）
    7.2.4 扩展自己的合约（OK）
    7.2.5 合约的高阶函数（OK）
    7.2.6 带”???“的合约信息（OK）
    7.2.7 解析合约的错误消息（OK）
  7.3 通常的函数合约（OK）
    7.3.1 可选参数（OK）
    7.3.2 剩余参数（OK）
    7.3.3 关键字参数（OK）
    7.3.4 可选关键字参数（OK）
    7.3.5 case-lambda合约（OK）
    7.3.6 参数和结果的依赖（OK）
    7.3.7 检查状态的变化（OK）
    7.3.8 多个结果值（OK）
    7.3.9 固定但静态未知数量的参数（OK）
  7.4合约：一个全面的例子（OK）
  7.5 结构的合约（OK）
    7.5.1 对特定值的确保（OK）
    7.5.2 对所有值的确保（OK）
    7.5.3 检查数据结构的特性（OK）
  7.6 用#:exists和#:∃抽象合约（OK）
  7.7 额外的例子（OK）
    7.7.1 客户管理器的组成（OK）
    7.7.2 参数（简单）栈（OK）
    7.7.3 字典（OK）
    7.7.4 队列（OK）
  7.8 建立新合约（OK）
    7.8.1 合约结构属性（OK）
    7.8.2 所有的警告和报警（OK）
  7.9 陷阱（OK）
    7.9.1 合约和eq?（OK）
    7.9.2 合约的范围和define/contract（OK）
    7.9.3 合约的生存期和判定（OK）
    7.9.4 定义递归合约（OK）
    7.9.5 混合set!和合约（OK）

8 输入和输出（OK）
  8.1 端口的种类（OK）
  8.2 默认端口（OK）
  8.3 读和写Racket数据（OK）
  8.4 数据类型和序列化（OK）
  8.5 字节、字符和编码（OK）
  8.6 输入/输出模式（OK）

9 正则表达式（OK）
  9.1 写regexp模式（OK）
  9.2 匹配正则表达式模式（OK）
  9.3 基本申明（OK）
  9.4 字符和字符类（OK）
    9.4.1 常用的字符类（OK）
    9.4.2 POSIX字符类（OK）
  9.5 量词（OK）
  9.6 簇（OK）
    9.6.1 后向引用
    9.6.2 非捕捉簇（OK）
    9.6.3 回廊（OK）
  9.7 替代（OK）
  9.8 回溯（OK）
  9.9 前后查找（OK）
    9.9.1 向前查找（OK）
    9.9.2 向后查找（OK）
  9.10 一个扩展示例（OK）

10 异常与控制（OK）
  10.1 异常（OK）
  10.2 提示和中止（OK）
  10.3 延续（OK）

11 迭代和推导（OK）
  11.1 序列构造（OK）
  11.2 for和for*（OK）
  11.3 for/list和for*/list（OK）
  11.4 for/vector和for*/vector（OK）
  11.5 for/and和for/or（OK）
  11.6 for/first和for/last（OK）
  11.7 for/fold和for*fold（OK）
  11.8 多值序列（OK）
  11.9 打断迭代（OK）
  11.10 迭代性能（OK）

12 模式匹配（OK）

13 类和对象（OK）
  13.1 方法（OK）
  13.2 初始化参数（OK）
  13.3 内部和外部名称（OK）
  13.4 接口（Interface）（OK）
  13.5 Final、Augment和Inner（OK）
  13.6 控制外部名称的范围（OK）
  13.7混合（mixin）（OK）
    13.7.1 混合和接口（OK）
    13.7.2 mixin表（OK）
    13.7.3 参数化的混合（OK）
  13.8 特征（trait）（OK）
    13.8.1 混合集的特征（OK）
    13.8.2 特征的继承与超越（OK）
    13.8.3 trait表
  13.9类合约（OK）
    13.9.1 外部类合约（OK）
    13.9.2 内部类合约（OK）

14 单元（部件）（OK）
  14.1 签名和单元（OK）
  14.2 调用单元（OK）
  14.3 连接单元（OK）
  14.4 一级单元（OK）
  14.5 完整的-module签名和单元（OK）
  14.6 单元合约（OK）
    14.6.1 给签名添加合约（OK）
    14.6.2 给单元添加合约（OK）
14.7 unit（单元）与module（模块）的比较（OK）

15 反射和动态求值（OK）
  15.1 eval（OK）
    15.1.1 本地域（OK）
    15.1.2 命名空间（OK）
    15.1.3 命名空间和模块（OK）
  15.2 操纵的命名空间（OK）
    15.2.1 创建和安装命名空间（OK）
    15.2.2 共享数据和代码的命名空间（OK）
  15.3 脚本求值和使用load（OK）

16 宏（Macro）（OK）
  16.1 基于模式的宏（OK）
    16.1.1 define-syntax-rule（OK）
    16.1.2 词法范围（OK）
    16.1.3 define-syntax和syntax-rules（OK）
    16.1.4 匹配序列（OK）
    16.1.5 标识符宏（OK）
    16.1.6 set!转化器（OK）
    16.1.7 宏的宏生成（OK）
    16.1.8 扩展的例子：函数的参考调用（OK）
  16.2 通用宏转化器（OK）
    16.2.1 语法对象（OK）
    16.2.2 宏转化器程序（OK）
    16.2.3 混合模式和表达式：syntax-case（OK）
    16.2.4 with-syntax和generate-temporaries（OK）
    16.2.5 编译和运行时阶段（OK）
    16.2.6 通用阶段等级（OK）
      16.2.6.1 阶段绑定（OK）
      16.2.6.2 阶段和模块（OK）
    16.2.7 语法污染（OK）
      16.2.7.1 破坏模式（OK）
      16.2.7.2 污染和代码检查（OK）
      16.2.7.3 保护的导出（……）

17 创建语言
  17.1 模块语言
    17.1.1 隐式绑定
    17.1.2 使用#lang s-exp
  17.2 读者的扩展
    17.2.1 源位置
    17.2.2 可读性
  17.3 定义新的#lang语言
    17.3.1 指定#lang语言
    17.3.2 使用#lang reader
    17.3.3 使用#lang s-exp syntax/module-reader
    17.3.4 安装语言
    17.3.5 源操纵配置
    17.3.6 模块操纵配置

18 并发和同步
  18.1 线程
  18.2 线程的信箱
  18.3 信号量
  18.4 通道
  18.5 带缓冲的异步通道
  18.6 同步事件和sync

19 性能
  19.1 DrRacket中的性能
  19.2 字节码和即时（JIT）编译器
  19.3 模块与性能
  19.4 功能调用优化
  19.5 突变与性能
  19.6 letrec性能
  19.7 短数（fixnum）和大数（flonum）的最优化
  19.8 非检查的、非安全的操作
  19.9 外部指针
  19.10 正则表达式性能
  19.11 内存管理
  19.12 可达性和垃圾收集
  19.13 弱盒测试
  19.14 减少垃圾收集暂停

20 并行
  20.1 与未来的平行性
  20.2 点平行
  20.3 分布式的地方

21 运行和创建可执行文件
  21.1运行racket和gracket
    21.1.1 互动模式
    21.1.2 模块模式
    21.1.3 装载模式
  21.2 脚本
    21.2.1 UNIX脚本
    21.2.2 Windows批处理文件
  21.3 创建独立的可执行文件

22 更多的库
  22.1 图形和图形用户界面
  22.2 Web服务器
  22.3 使用外部库
  22.4 更多的库

23 Racket和Scheme的方言
  23.1 更多的Racket
  23.2 标准
    23.2.1 R5RS
    23.2.2 R6RS
  23.3 教学

24 命令行工具和编辑器选择
  24.1命令行工具
    24.1.1编译和配置：raco
    24.1.2 互动求值
    24.1.3 完整的Shell
  24.2 Emacs
    24.2.1 专家模式
    24.2.2 较小模式
    24.2.3 包specific到有害模式
  24.3 vim
  24.4 Sublime Text

参考文献

索引
